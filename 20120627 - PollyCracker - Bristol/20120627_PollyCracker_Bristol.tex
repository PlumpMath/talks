\documentclass[10pt]{beamer}
\usepackage[utf8x]{inputenc}

\definecolor{myorange}{HTML}{FF8000}
\definecolor{myblue}{HTML}{80B3FF}
\definecolor{dredcolor}{rgb}{.5,0.0,0.0}
\definecolor{dlightgray}{rgb}{.9,.9,.9}

\mode<presentation>
{
  \setbeamercovered{transparent}
  \setbeamercolor{normal text}{fg=white,bg=gray}
  \setbeamercolor{alerted text}{fg=white}
  \setbeamercolor{example text}{fg=white}
  \setbeamercolor{background canvas}{bg=darkgray} 
  \setbeamercolor{structure}{fg=white}

  \setbeamercolor{block title}{bg=dredcolor,fg=white}
  \setbeamercolor{block body}{bg=white,fg=darkgray}

  \setbeamercolor{palette primary}{use=structure,fg=structure.fg}

  \setbeamercolor{math text}{}
  \setbeamercolor{math text inlined}{parent=math text}
  \setbeamercolor{math text displayed}{parent=math text}

  \setbeamercolor{normal text in math text}{}

  \setbeamercolor{local structure}{parent=structure}

  \setbeamercolor{titlelike}{parent=structure}

  \setbeamercolor{title}{parent=titlelike}
  \setbeamercolor{title in head/foot}{parent=palette quaternary}
  \setbeamercolor{title in sidebar}{parent=palette sidebar quaternary}

  \setbeamercolor{subtitle}{parent=title}
}

\usepackage[utf8x]{inputenc}
\usepackage[final]{pdfpages}
\usepackage{multicol}
\usepackage[vlined]{algorithm2e}
\usepackage{tikz}
\usepackage{listings}



\lstdefinelanguage{Sage}[]{Python}
{morekeywords={True,False,sage},
sensitive=true}

\lstset{frame=none,
          showtabs=False,
          showspaces=False,
          showstringspaces=False,
          commentstyle={\color{pink}\bfseries},
          keywordstyle={\color{white}\bfseries},
          language = Sage,
  basicstyle=\footnotesize,               }


\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{xspace}
\usepackage{hyperref}

\renewcommand{\emph}[1]{{\bf #1}}
\newcommand{\PolyBoRi}{\textsc{PolyBoRi}\xspace}
\newcommand{\ideal}[1]{\langle {#1} \rangle}
\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\F}{\field{F}}

\usepackage{xargs}

\newcommand{\NN}{{\mathbb N}}
\newcommand{\ZZ}{{\mathbb Z}}
\newcommand{\QQ}{{\mathbb Q}}
\newcommand{\RR}{{\mathbb R}}
\newcommand{\CC}{{\mathbb C}}
\newcommand{\ie}{\textit{i.e.},\xspace}
\newcommand{\f}{\mathbf{f}}
\newcommand{\HM}{{\rm HM}}

\newcommand{\px}{\phantom{x}}

\newcommand{\sig}[1]{\textnormal{sig}(#1)\xspace}
\newcommand{\e}{\textbf{e}}
\newcommand{\LV}[1]{\ensuremath{\textsc{LV}(#1)\xspace}}
\newcommand{\LT}[1]{\ensuremath{\textsc{LT}(#1)\xspace}}
\newcommand{\LM}[1]{\ensuremath{\textsc{LM}(#1)\xspace}}
\newcommand{\LC}[1]{\ensuremath{\textsc{LC}(#1)\xspace}}
\newcommand{\LCM}[1]{\ensuremath{\textsc{LCM}(#1)\xspace}}
\newcommand{\expvec}{\ensuremath{\textnormal{expvec}}}

\newcommand{\Encode}[1]{\ensuremath{\mathbf{Encode}}(#1)\xspace}
\newcommand{\Decode}[1]{\ensuremath{\mathbf{Decode}}(#1)\xspace}

\newcommand{\SPC}{\ensuremath{\mathcal{SPC}}\xspace}

\newcommand{\ord}[1]{\ensuremath{\mathcal{O}\!\left(#1\right)}}

\newcommand{\FX}{\ensuremath{{{\F}[x_1,\dots,x_n]}}}
\newcommand{\sys}{\ensuremath{f_1,\dots,f_m}\xspace}

\newcommand{\SKE}{\ensuremath{\mathcal{SKE}}\xspace}
\newcommand{\PKE}{\ensuremath{\mathsf{PKE}}\xspace}

\newcommand{\secpar}{\lambda}
\newcommandx*\GBGen[2][1={}]{\ensuremath{\mathsf{GBGen}_{\mathsf{#1}}(#2)}\xspace}
\newcommand{\Gen}{\mathsf{Gen}}
\newcommand{\Enc}{\mathsf{Enc}}
\newcommand{\Eval}{\mathsf{Eval}}
\newcommand{\Dec}{\mathsf{Dec}}
\newcommand{\SK}{\mathsf{SK}}
\newcommand{\PK}{\mathsf{PK}}
\newcommand{\msg}{\mathsf{m}}
\newcommand{\cph}{\mathsf{c}}
\newcommand{\key}{\mathsf{k}}
\newcommand{\MsgSp}{\mathsf{MsgSp}}
\newcommand{\RndSp}{\mathsf{RndSp}}
\newcommand{\ReRand}{\mathsf{ReRand}}
\newcommand{\Circt}{C}

\newcommand{\A}{\ensuremath{\mathcal{A}}\xspace}
\newcommand{\B}{\ensuremath{\mathcal{B}}\xspace}
\newcommand{\IND}{\mathsf{IND}}			
\newcommand{\ind}{\mathsf{ind}}
\newcommand{\CPA}{\mathsf{CPA}}	
\newcommand{\BCPA}{\mathsf{BCPA}}			
\newcommand{\cpa}{\mathsf{cpa}}
\newcommand{\bcpa}{\mathsf{bcpa}}
\newcommand{\KDM}{\mathsf{KDM}}			
\newcommand{\kdm}{\mathsf{kdm}}
\newcommand{\Initialize}{\mathbf{Initialize}}
\newcommand{\Finalize}{\mathbf{Finalize}}
\newcommand{\LR}{\mathbf{Left\mbox{-}Right}}
\newcommand{\Encrypt}{\mathbf{Encrypt}}
\newcommand{\Sample}{\mathbf{Sample}}
\newcommand{\Challenge}{\mathbf{Challenge}}
\newcommand{\sample}{{\;{{\leftarrow}_\$}\;}}
\newcommand{\Adv}{\mathbf{Adv}}
\newcommand{\true}{\mathsf{T}}
\newcommand{\false}{\mathsf{F}}

\newcommand{\GB}{\ensuremath{\mathsf{GB}}\xspace}
\newcommand{\IM}{\ensuremath{\mathsf{IM}}\xspace}

\newcommand{\GBN}{\ensuremath{\mathsf{GBN}}\xspace}
\newcommand{\IMN}{\ensuremath{\mathsf{IMN}}\xspace}
\newcommand{\LWE}{\ensuremath{\mathsf{LWE}}\xspace}

\newcommand{\hll}[1]{{\color{pink}\mathbf #1}}


%% Theorems
\DeclareMathOperator{\Dff}{D}
\newtheorem{rem}{Remark}[section]
\newtheorem{lem}{Lemma}[section]
\newtheorem{theo}{Theorem}[section]
\newtheorem{prop}{Proposition}[section]
\newtheorem{proper}{Property}[section]
\newtheorem{coro}{Corollary}[section]
\newtheorem{defi}{Definition}


\newcommand{\vectx}[2]{#1_1,\ldots,#1_{#2}}
\newcommand{\polring}[3]{#1[\vectx{#2}{#3}]}
\newcommand{\vectfx}[4]{#1_1(\vectx{#3}{#4}),\ldots,#1_{#2}(\vectx{#3}{#4})}
\newcommand{\Fi}[1]{\textrm{F}$_{#1}$}

\newcommand{\I}{\ensuremath{\mathcal{I}}\xspace}

\renewcommand{\emph}[1]{\textbf{#1}}

\newcommand{\poly}[1]{\ensuremath{\mathrm{poly}(#1)}\xspace}

\title{Polly Cracker, Revisited}

\author{\textbf{Martin Albrecht}\inst{1} 
\and Pooya Farshim\inst{2} 
\and Jean-Charles Faugère\inst{1} 
\and Gottfried Herold\inst{3}
\and Ludovic Perret\inst{1}}
\institute{
1 POLSYS Project - INRIA, UPMC, Univ Paris 06\\
2 Information Security Group, Royal Holloway, University of London\\
3 Ruhr Universität Bochum
}

\date{Bristol, 27.July 2012}
\AtBeginSection[]
{
   \begin{frame}
       \frametitle{Outline}
       \tableofcontents[currentsection]
   \end{frame}
}


\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}{Outline}
\tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}
\frametitle{Homomorphic Encryption}
\begin{itemize}
 \item Homomorphic encryption is a cryptographic primitive which allows to perform arbitrary computation over encrypted data. 
 \item Given a function $f$ and a ciphertext $c$ encrypting a plaintext $m$, it is possible to transform $c$ to a new ciphertext $c'$ which encrypts $f(m)$.
\end{itemize}

\begin{block}{}
We can evaluate multivariate (Boolean) polynomials over ciphertexts.
\end{block}


\begin{thebibliography}{Gen09}
\bibitem{Gen09}
Craig Gentry.
\newblock Fully homomorphic encryption using ideal lattices.
\newblock In {\em STOC 09: Proceedings of the 41st annual ACM symposium on
  Theory of computing}, pages 169--178, 2009.
\end{thebibliography}
\end{frame}

\begin{frame}
\frametitle{An abstract scheme}

Let $\I \subset P$ be some ideal in some ring and denote by $\Encode{}$ a function with inverse $\Decode{}$ that maps bit-strings to elements in the quotient ring $P/\I$.

\vspace{1em}

If \[\Decode{\Encode{m_0}\ \circ\ \Encode{m_1}} = m_0\ \circ\ m_1 \mbox{ for } \circ \in \{+,\cdot\},\] we can encrypt a message $m$ as
\[
 c = f + \Encode{m} \textnormal{ for } f \mbox{ randomly chosen in } \I.
\]

Decryption is equivalent computing remainders modulo $\I$ in $P$. 

\vspace{1em}

Homomorphic features follow from the definition of an ideal.
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{``Instantiations'' of this scheme} 

\begin{itemize}
 \item $P = \field{Z}$
 \item $\I = \ideal{p}$ where $p$ is an odd integer
 \item $\Encode{\cdot}$ is not injective
\end{itemize}

\begin{thebibliography}{Gen09}
\bibitem{DGHV10}
Marten van Dijk, Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan.
\newblock Fully homomorphic encryption over the integers.
\newblock In {\em Advances in Cryptology -- EUROCRYPT 2010}, volume 6110 of
  {\em Lecture Notes in Computer Science}, pages 24--43, 2010.
\end{thebibliography}

\vspace{0.5cm}

\begin{block}{Approximate GCD}
Given $q_ip + r_i$ where $r_i \ll p$, compute $p$. 
\end{block}


\framebreak

\begin{itemize}
 \item $P = \F_q[x_1,\dots,x_n]$
 \item $\I = \ideal{x_1 - s_1,\dots,x_n - s_n}$
 \item $\Encode{\cdot}$ is not injective
\end{itemize}

\begin{thebibliography}{Gen09}
\bibitem{cryptoeprint:2011:344}
Zvika Brakerski and Vinod Vaikuntanathan.
\newblock Efficient fully homomorphic encryption from (standard) {LWE}.
\newblock FOCS 2011, 2011.
\end{thebibliography}

\vspace{0.5cm}


\begin{block}{LWE}
Given $\sum_j a_{ij} x_j - \sum_j a_{ij} s_j + e_i$ compute $s_1,\dots,s_n$.
\end{block}


\framebreak

\begin{itemize}
 \item $P = \F_q[x_1,\dots,x_n]$
 \item $\I \approx \ideal{x_1 - s_1,\dots,x_n - s_n}$
 \item $\Encode{\cdot}$ {\it is} injective: PoSSo
\end{itemize}

\begin{thebibliography}{Gen09}
\bibitem{Koblitz:1998:AAC:275809}
Neal Koblitz, Alfred~J. Menezes, Yi-Hong Wu, and Robert~J. Zuccherato.
\newblock {\em Algebraic aspects of cryptography}.
\newblock Springer Verlag, Berlin, Heidelberg, New York, 1998.
\end{thebibliography}

\vspace{0.5cm}

\begin{block}{PoSSo/GB}
Given $\sum h_if_i$ for $f_i \in \I$ compute the Gröbner basis of $\ideal{f_1,\dots,f_m}$.
\end{block}

\vspace{0.5cm}

These schemes are known as {\bf Polly Cracker}.

\end{frame}

\begin{frame}
\frametitle{Our contribution} 

We show that all these schemes can be seen as special instances of problem, which we call \emph{Gröbner basis with noise} (GBN).

\vspace{1em}

Put differently, in response to

\vspace{2em}

\begin{thebibliography}{}
\bibitem{DBLP:journals/jsc/BarkeeCEMR94}
Boo Barkee, Deh~Cac Can, Julia Ecks, Theo Moriarty, and R.~F. Ree.
\newblock Why you cannot even hope to use {G}r{\"o}bner bases in {P}ublic {K}ey
  {C}ryptography: An open letter to a scientist who failed and a challenge to
  those who have not yet failed.
\newblock {\em Journal of Symbolic Computations}, 18(6):497--501, 1994.
\end{thebibliography}

\vspace{2em}

\begin{flushright}
\dots we say: {\bf yes we can!} \dots if we add noise 
\end{flushright}

\end{frame}


\section{An Old (?) Computational Problem: Gröbner Bases}

\begin{frame}[allowframebreaks]
\frametitle{Notation \& Definitions}
\begin{itemize}
 \item $P = \FX$ with some degree-compatible order on monomials.
 \item $P_{\leq b}$ elements in $P$ of degree at most $b$.
 \item $\LM{f}$ is the leading monomial appearing in $f \in P$.
 \item $\LC{f}$ is the coefficient corresponding to $\LM{f}$ in $f$.
 \item $\LT{f}$ is $\LC{f}\LM{f}$.
 \item $d$ is the degree of Gröbner bases in this talk.
 \item $b$ is the degree of random ideal elements in this talk.
\end{itemize}

\framebreak

An example in $\F[x,y,z]$ with term ordering \emph{deglex}:

\[f = 3yz + 2x + 1\]

\begin{itemize}
 \item $\LM{f} = yz$,
 \item $\LC{f} = 3$ and
 \item $\LT{f} = 3yz$.
\end{itemize}

\framebreak

\begin{definition}[Generated Ideal]
Let \sys be polynomials in $P$. Define the set
\[
\ideal{\sys} := \left\{ \sum_{i=1}^{m} h_i f_i : h_1 ,\dots , h_m \in P \right\}.
\]
This set $\I$ is an ideal called the ideal generated by $f_1, \dots, f_m$.
\end{definition}

\framebreak

\begin{definition}[Gr\"obner Basis]
Let $\I$ be an ideal of $\FX$ and fix a monomial ordering. A finite subset $$G = \{g_1 ,\dots , g_m \} \subset \I$$  is said to be a \emph{Gr\"obner basis} of $\mathcal{I}$ if for any $f \in \I$ there exists $g_i \in G$ with $$\LM{g_i} \mid \LM{f}.$$
\end{definition}

\vspace{0.5em}

\begin{itemize}
 \item If all $f_i$ linear, then Gröbner bases coincide with row echelon forms. 
 \item If all $f_i \in \F[x]$ then Gröbner bases coincide with GCDs.
\end{itemize}



\framebreak

For each ideal $\I$ and monomial ordering there is a unique \emph{reduced} Gröbner basis which can be computed in polynomial time from any Gröbner basis.

\vspace{0.5em}

\begin{block}{if you know the Gröbner basis you ``understand'' the ideal.}
Gröbner bases allow to compute remainders modulo $\I$: $$f\mod \I = f \mod G.$$
\end{block}

\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Generating Gröbner bases for Crypto}

\begin{definition}[S-Polynomial]
\label{def:spolynomials}
The S-polynomial of $f$ and $g$ is defined as
\[
S(f,g)\ =\ \frac{\LCM{\LM{f},\LM{g}}}{\LT{f}}\cdot f\ -\ \frac{\LCM{\LM{f},\LM{g}}}{\LT{g}}\cdot g.
\]
\end{definition}

\begin{theorem}
\label{thm:groebnerreducestozero}
A basis $G = \{g_1 ,\dots , g_s \}$ for an ideal $\I$ is a Gröbner basis if and only if all $S(g_i,g_j)$
reduce to zero by polynomial division.
\end{theorem}

\framebreak

\begin{tabular}{ll}
\begin{minipage}{0.4\textwidth}
\begin{algorithm}[H]
\Begin{
  \For{$0 \leq i < n$}{
        \eIf{$i > n - \ell - 1$}{$g_i \gets  x_i^d$\;}{ $g_i \gets  x_i$\;}
        \For{$m_j  \in M_{<\LM{g_i}}$}{
          $c_{ij} \sample \F_q;$ \\   $g_i \gets g_i + c_{ij}m_j$\;
    }
  }
  \Return{$\{g_0,\ldots,g_{n-1}\}$}\;
}
\label{alg.gbgen}
\end{algorithm}
\end{minipage}
&
\begin{minipage}{0.5\textwidth}
\begin{theorem}
Let $f,g \in \F[x_0,\dots,x_{n-1}]$ with $a=\LM{f}$ and $b=\LM{g}$ and $$\LCM{a,b} = a \cdot b.$$ Then $$S(f,g) \underset{\{f,g\}}{\longrightarrow} 0.$$
\label{def:buchberger_first_criterion}
\end{theorem}
\end{minipage}\\
\end{tabular}
\end{frame}

\begin{frame}
\frametitle{Sampling Elements in $\I$} 

\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{algorithm}[H]
\Begin{
 $f \sample P_{\leq b}$\;
 $f \gets f - f \mod G$\;
 \Return{$f$}\;
}
\caption{$\Sample()$}
\end{algorithm}
\end{minipage}
\end{center}
\begin{block}{}
This sampling is uniform for elements $f \in \I$ with $\deg(f) \leq b$ because $P = \I \oplus P/\I$.
\end{block}
\end{frame}



\begin{frame}[allowframebreaks]
\frametitle{Classical Computational Problems}

\begin{description}
 \item[GB] Given access to $m$ samples from $\I$ recover $G$.
 \item[IM] Given access to $m$ samples from $\I$ and a challenge $f \in P$, decide if $f \mod G = 0$.
\end{description}

\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Hardness}
\begin{lemma}[IM $<=>$ GB]
\label{lem:IR=GB} 
If we have an oracle which solves the \IM problem with overwhelming probability, we can construct an algorithm which solves the \GB problem and vice versa.
\end{lemma}

\begin{proof}[Proof for first direction]
Let $g_i \in G$ arbitrary and let $m_i = \LM{g_i}$ 

\vspace{0.5em}

Pick a random $r_i \in P/\I$ and ask for ideal membership of $\tilde{g}_i = m_i + r_i$. If true, then $m_i + r_i \in \ideal{G}$ with leading monomial $m_i$. Add it to a list $\tilde{G}$.

\vspace{0.5em}

Repeat this process for all leading monomials $m$ and all tails $r_i$. 

\vspace{0.5em}

The list $\tilde{G}$ is a list of elements $\in \ideal{G}$ with $\LM{\tilde{G}} \supseteq \LM{G}$ which implies $\tilde{G}$ is a Gröbner basis.
\end{proof}

\framebreak

Assuming that $\sys$ is a random system, the complexity of currently best known algorithms (i.e.  with $F_5$) to solve the GB problem is given by
\[
 \ord{ { {{n + D} \choose D}}^\omega } = \ord{ (n^D)^\omega}
\]
where $2 \leq \omega < 3$ is the linear algebra constant, and $D$ is given by the index of the first non-positive coefficient of:
\[
 \sum_{k\geq 0} c_k z^k = \frac{(1-z^{b})^{m}}{(1-z)^{n}}.
\]

Thus Gröbner bases are exponential in $n$, if $D$ is polynomial in $n$.

\framebreak

\begin{definition}[\GB/\IM Assumption]
\label{def.GB.assump}
Let $\mathcal{P}$ be such that $n(\secpar)=\mathrm{\Omega}(\secpar)$. Assume $b-d >0$, $b>1$, and that $m(\secpar) = c\cdot n(\secpar)$ for a constant $c \ge 1$. Then the advantage of any ppt algorithm in solving  the \GB/\IM problem is negligible as function of $\secpar$. 
\end{definition}
\end{frame}

\section{Symmetric Polly Cracker}

\begin{frame}[allowframebreaks]
\frametitle{Symmetric PollyCracker} 

\begin{figure}[ht]
\begin{small}
\framebox{
\begin{tabular}{ll}
\begin{minipage}{0.32\textwidth}
\underline{\bf $\Gen_{\mathcal{P},\GBGen{\cdot},d,b}(1^\secpar)$:}
\begin{tabular}{l}
    {\bf begin}\\
    \vline \px $P \sample \mathbf{P}_\secpar$;\\
    \vline \px $G \sample \mathsf{GBGen}(1^\secpar,P,d,\ell)$;\\
    \vline \px $\SK \gets (G,P,b)$;\\
 \vline \px $\PK \gets (P,b)$;\\
    \vline \px {\bf return} $(\SK,\PK)$;\\
    {\bf end}\\
\end{tabular} 
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\underline{\bf $\Enc(\mathsf{m},\SK)$}: \\
\begin{tabular}{l}
 {\bf begin}\\
 \vline \px $f \sample P_{\leq b}$;\\
 \vline \px $f' \gets f \bmod G$;\\
 \vline \px $f \gets f - f'$;\\
 \vline \px $\mathsf{c} \leftarrow \mathsf{m} + f$; \\
 \vline \px {\bf return} $\mathsf{c}$;\\
 {\bf end}\\
\end{tabular}
\end{minipage}
\\
\begin{minipage}{0.45\textwidth}
\underline{\bf $\Dec(\mathsf{c},\SK)$}: \\
\begin{tabular}{l}
    {\bf begin}\\
    \vline \px $\mathsf{m} \leftarrow \mathsf{c} \bmod G$;\\
    \vline \px {\bf return} $\mathsf{m}$;\\
    {\bf end}\\
\ \\
\end{tabular}
\end{minipage}
&
\begin{minipage}{0.45\textwidth}
\underline{\bf $\Eval(\mathsf{c}_0,\dots,\mathsf{c}_{t-1},\Circt,\PK)$}: \\
\begin{tabular}{l}
{\bf begin}\\
\vline \px apply the $\mathsf{Add}$ and $\mathsf{Mult}$ \\
\vline \phantom{xi} gates of $\Circt$ over $P$; \\
\vline \px {\bf return} the result;\\
{\bf end}\\
\end{tabular}
\end{minipage}
\end{tabular}
}
\end{small}
\caption{The noise-free symmetric Polly Cracker scheme $\SPC_{\mathcal{P},\GBGen{\cdot},d,b}$.}
\label{fig.spc}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Security}
The $m(\cdot)$-time $\IND\mbox{-}\CPA$ security is defined by requiring that the advantage of any ppt $\A$
\[
\Adv^{\ind\mbox{-}\bcpa}_{m(\cdot),\SKE,\A}(\secpar) := 2\cdot \Pr \left[ {\IND\mbox{-}\BCPA}^{\A}_{m(\cdot),\SKE}(\secpar) \Rightarrow \true \right] - 1 
\]
is negligible in $\lambda$. The difference with the usual CPA security is that the adversary can query the encryption oracle at most  $m(\secpar)$ times. 

\begin{theorem}
\label{thm:spc}
For any  $\A$ against the $m$-time $\IND\mbox{-}\BCPA$ security of $\SPC$ there exists a $\B$ against the \IM problem such that
\[
\Adv^{\ind\mbox{-}\bcpa}_{m,\SPC,\A}(\secpar)  = 
2\cdot \Adv^{\mathsf{im}}_{\mathcal{P},\GBGen{\cdot},d,b,m,\B}(\secpar).
\]

Conversely, fory any $\A$ against the \IM problem there exists a $\B$ against the $m$-time $\IND\mbox{-}\BCPA$ security of $\SPC$ such that 
\[
\Adv^{\mathsf{im}}_{\mathcal{P},\GBGen{\cdot},d,b,m,\A}(\secpar) =
\Adv^{\ind\mbox{-}\bcpa}_{m,\SPC,\B}(\secpar).
\]
\end{theorem}

\end{frame}


\section{Symmetric to Asymmetric Conversion}

\begin{frame}
\frametitle{Conversions in the Literature}

\begin{itemize}
 \item There are a few techniques in the literature, which convert an $\IND\mbox{-}\CPA$ symmetric additive homomorphic scheme to an $\IND\mbox{-}\CPA$ public-key additive homomorphic scheme.
 \item One such conversion is to publish $N$ encryptions of zero $f_1,\dots,f_N$ and to encrypt as $$c = \sum_{s \in S} f_s + m$$ where $S$ is a small subset of $\{1,\dots,N\}$.
 \end{itemize}

\vspace{1em}
\begin{block}{}
While PollyCracker is additive homomorphic and secure up to some bound, none of the proposed conversions give a secure scheme.
\end{block}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Impossibility Result} 
\begin{theorem}[Dickenstein, Fitchas, Giusti, and Sessa]
\label{theorem:dfgs}
Let $\I = \ideal{f_1,\dots, f_m}$ be an ideal in $P = \FX, h$ be such that $\deg(h) \leq D$, and $$h - (h \mod \I) = \sum_{i=1}^{m}h_if_i,$$ where $h_i \in P$ and $\deg(h_i f_i ) \leq D$. 

\vspace{1em}

Let $G$ be the output of some Gr\"obner basis computation algorithm up to degree $D$ (i.e., all computations with degree greater than $D$ are ignored and dropped). 

\vspace{1em}

Then $h \mod \I$ can be computed by polynomial reduction of $h$ via $G$.
\end{theorem}

\framebreak

\begin{theorem}
\label{theorem:gbeasy}
Let $\I = \ideal{\sys}$ be an ideal in $P = \FX$. If there is a ppt algorithm \A which samples elements from $\I$ uniformly given only $(\sys) \in \I$, then there exists a ppt algorithm $\B$ which computes a Gröbner basis for $\I$.
\end{theorem}

\begin{proof}
\begin{enumerate}
 \item We can compute the normal forms of any $f$ produced by \A in polynomial time since we know $\sys$.
 \item If $f$ is arbitrary in the ideal $\I$, we know that normals forms are equivalent to Gröbner basis computations.
\end{enumerate}
Thus, we have a polynomial time algorithm for computing Gröbner bases.
\end{proof}
\end{frame}

\bibliographystyle{alpha}

\section{The New Computational Problem: Gröbner Bases with Noise}

\begin{frame}
\frametitle{Foreword} 

We will now focus on linear Gröbner bases for the rest of this talk
\begin{itemize}
 \item here things thing is nice and easy;
 \item we can get multiplicative homomorphicity; and
 \item we have a close relation to LWE.
\end{itemize}

To see what issues arise for $d>1$, read \cite{Gottfried, Journal} or ask during the Q\&A.

\begin{thebibliography}{foobar}
\bibitem{Gottfried}
Gottfried Herold
\newblock Polly Cracker, revisited, revisited
\newblock PKC 2012, Springer Verlag 2012

\bibitem{Journal}
with P. Farshim, J.-C.\ Faugère, G.\ Herold and L.\ Perret
\newblock Polly Cracker, revisited
\newblock full version, in preparation

\end{thebibliography}


\end{frame}


\begin{frame}
\frametitle{Discrete Gaussian}

\begin{definition}[Discrete Gaussian Distribution]
Let $\alpha > 0$ be a real number and $q \in \mathbb{N}$. The discrete Gaussian distribution $\chi_{\alpha, q}$, is a Gaussian distribution rounded to the nearest integer and reduced modulo $q$ with mean zero and standard deviation $\alpha q$.
\end{definition}

\end{frame}

\begin{frame}
\frametitle{Sampling Noisy Elements in $\I$} 

\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{algorithm}[H]
\Begin{
 $f \sample P_{\leq b}$\;
 $f \gets f - (f \mod G)$\;
 {\color{pink} $e \sample \chi$;}\\
 \Return{$f + e$}\;
}
\caption{$\Sample()$}
\end{algorithm}
\end{minipage}
\end{center}

\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Noisy Variants of Classical Computational Problems}

\begin{description}
 \item[GBN] Given access to $m$ noisy samples from $\I$ recover $G$.
 \item[IMN] Given access to $m$ noisy samples from $\I$ and a challenge $f \in P$, recover if $f \mod G \approx 0$.
\end{description}

\begin{block}{}
Our Ideal Membership with Noise (\IMN) is essentially Gentry's Ideal Coset problem for noisy polynomials. 
\end{block}

\end{frame}

\begin{frame}
\begin{lemma}[\IMN Hard $\Leftrightarrow$ \GBN Hard] \label{lem:IMN=GBN}
For any ppt adversary $\A$ against the \IMN problem for $d=1$ and $q = \poly{n}$, there exists a ppt adversary $\B$ against the \GBN problem such that
\[
\Adv^{\mathsf{imn}}_{\mathcal{P},\GBGen{\cdot},d,\ell,b,\chi,\A}(\secpar)  \le  \Adv^{\mathsf{gbn}}_{\mathcal{P},\GBGen{\cdot},d,\ell,b,\chi,\B}(\secpar).
\]
\end{lemma}
\dots and vice versa. 

\begin{proof}[Proof Sketch]
The proof proceeds as in the \GB $\Leftrightarrow$ \IM case except that we can amplify our confidence in the output.
\end{proof}

\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Security}

\begin{lemma}[\LWE Hard $\Rightarrow$ \GBN Hard for $d=1,b=1$]
Let $q$ be a prime number. Then for any ppt adversary \A against the \GBN problem with $b=d=1$, there exists a ppt adversary $\B$ against the \LWE problem such that
\[
\Adv^{\mathsf{gbn}}_{\mathcal{P},\GBGen{\cdot},1,1,\chi,\A}(\secpar)  = \Adv^{\mathsf{lwe}}_{n,q,\chi,\B}(\secpar).
\]
\label{lem:GBN=LWE}
\end{lemma}

\begin{proof}
Whenever \A calls its $\Sample$ oracle, \B queries its own $\Sample$ oracle to obtain $(a, b)$ where $a = (a_0,\dots,a_{n-1})$. It returns $\sum a_ix_i - b$ to \A. When \A calls its $\Finalize$ on $G$, since $d=1$, we may assume that $G$ is of the form $[x_0 - s_0, \dots, x_{n-1} - s_{n-1}]$ with $s_i \in \F_q$. Algorithm \B terminates by calling its $\Finalize$ oracle on $s=(s_0,\dots,s_{n-1})$. 
\end{proof} 


\framebreak

\begin{lemma}[\GBN Hard for $2b$ $\Rightarrow$ \GBN Hard for $b$]
\label{lem:GBN-degrees}
For any ppt adversary $\A$ against the \GBN problem at degree $b$ with noise $\chi_{\alpha, q}$, there exists a ppt adversary $\B$ against the \GBN problem at degree $2b$ with noise $\chi_{\sqrt{2N} \alpha^2q, q}$ such that
\[
\Adv^{\mathsf{gbn}}_{\mathcal{P},\GBGen{\cdot},d,b,\chi_{\alpha, q},\A}(\secpar)  = \Adv^{\mathsf{gbn}}_{\mathcal{P},\GBGen{\cdot},d,2b,\chi_{\sqrt{2N} \alpha^2q, q},\B}(\secpar)
\]
for $N = {n + b \choose b}$. 
\end{lemma}

\begin{proof}
Multiply samples $f_i,f_j$  to get $f_{i,j} = f_i \cdot f_j$. To ensure sufficient randomness, sum up $2N$ such products.
\end{proof}

\framebreak

Approximate GCD:

\begin{itemize}
 \item The \GBN problem for $n=1$ is the approx.\ GCD problem over $\F_q[x]$. 
 \item This problem has not yet received much attention, and hence it is unclear under which parameters it is hard. 
 \item However, the notion of a Gröbner basis can been extended to $\mathbb{Z}[x_0,\dots,x_{n-1}]$.
 \item This implies a version of the \GBN problem over $\mathbb{Z}$. 
 \item This can be seen as a direct generalisation of the approximate GCD problem in $\mathbb{Z}$.
\end{itemize}

\framebreak

\GBN over $\F_2$:

\begin{itemize}
 \item For $d=1$ and $q=2$ we can reduce \textsf{Max-3SAT} instances to \GBN instances by translating each clause individually to a Boolean polynomial. 
 \item The Gröbner basis returned by an arbitrary algorithm $\A$ solving \GBN using a \emph{bounded number} of samples will provide a solution to the \textsf{Max-3SAT} problem.
 \item Vice versa, we may convert a \GBN problem for $d=1$ to a \textsf{Max-SAT} problem (more precisely \textsf{Partial Max-Sat}) by running an ANF to CNF conversion algorithm.
\end{itemize}
 
\framebreak

Best known attack (for $d=1$):

\begin{itemize}
 \item We reduce \GBN to a larger \LWE instance.
 \item Denote by $N = {n + b \choose b}$ the number of monomials up to degree $b$. 
 \item Let $\mathcal{M}: P \rightarrow \F_q^N$ be a function which maps polynomials in $P$ to vectors in $\F_q^N$ by assigning the $i$-th component of the image vector the coefficient of the $i$-th monomial $\in M_{\leq b}$. 
 \item Reply to each $\Sample$ query by the \LWE oracle by calling the \GBN $\Sample$ oracle to retrieve $f$, compute $v = \mathcal{M}(f)$ and return $(a,b)$ with $a=(v_{N-1},\dots,v_{1})$ and $b=-v_0$. 
 \item When the \LWE oracle queries its $\Finalize$ with $s$ query the \GBN $\Finalize$ with $[x_0 - s_0,\dots,x_{n-1} - s_{n-1}]$. 
\end{itemize}

\end{frame}

\section{An Application: Homomorphic Encryption}

\begin{frame}
\frametitle{Polly Cracker with Noise}
\begin{itemize}
 \item \GBN/\IMN allow to construct a noisy version of our symmetric Polly Cracker scheme: $\mathcal{SPCN}$.
 \item $\mathcal{SPCN}$ is $\IND\mbox{-}\CPA$ under the \GBN assumption.
 \item Using any symmetric-to-asymmetric conversion from literature this leads to a public-key Polly Cracker scheme.
 \item This scheme is somewhat homomorphic and can support a fixed but arbitrary number of multiplications.
 \item This also implies that Regev's public-key scheme based on \LWE is multiplicative homomorphic under some choice of parameters.
\end{itemize}

\begin{eqnarray*}
c_0 \cdot c_1 &=& (m_0 + 2e_1 + \sum h_{0i}g_i) \cdot (m_1 + 2e_1 + \sum h_{1i}g_i)\\
              &=& m_0m_1 + 2e_0e_1 + 2\tilde{e} + \sum \tilde{h}_ig_i\\
\end{eqnarray*}
\end{frame}

\section{Appendix}

\begin{frame}
\frametitle{Abstract Nonsense?}

Generalising and unifying known things is fun, but is it useful? That is, do results from one instantiation carry over to another?

\vspace{1em}

\begin{block}{Arora\&Ge's algorithm for LWE} 
\begin{enumerate}
 \item Compute $h_i = f_i \cdot \prod_{j=1}^{|r|}\left((f_i+j)\cdot (f_i-j)\right)$ for samples $f_i$.
 \item Compute the Gröbner basis of $\ideal{h_0,\dots,h_{m-1}}$.
\end{enumerate}
\end{block}

\begin{block}{Chen\&Nguyen's algorithm for AGCD} 
\begin{enumerate}
 \item Compute $h_1 = f \cdot \prod_{j=1}^{|r|}\left((f+j)\cdot (f-j)\right) \bmod h_0$ for noisy sample $f$ and clean sample $h_0$.
 \item Compute the Gröbner basis of $\ideal{h_0,h_1}$.
\end{enumerate}
\end{block}

\end{frame}

\begin{frame}[allowframebreaks,fragile]
\frametitle{Ring-LWE} 

Compute $a_i^{-1} \cdot (a_i \cdot s + e_i) \approx s$ where all computations are $\bmod x^n + 1$.

\vspace{1em}

\begin{quote}
Given that this new approach allows one to cast both LWE and approximate GCD in the same framework, can one also capture ring-LWE.
\end{quote}
\vspace{-2em}
\begin{flushright}
-- Bristol Cryptography Blog 
\end{flushright}

\vspace{1em}

To compute $a_i^{-1}$ in $P = \mathbb{F}_q[x] / \ideal{x^n+1}$ we run the extended GCD algorithm which returns $(g,v,w)$ for inputs $a,b$ such that $$g = v \cdot a + w \cdot a.$$ Hence, for our inputs it will compute $$1= v\cdot a_i + w \cdot (x^n + 1) \textnormal{ and thus }v \equiv a_i^{-1} \mod x^n + 1.$$

\framebreak

In the language of Gröbner bases the extended GCD equivalent is often called ``lifting''.

\vspace{0.5em}

\begin{block}{}
Given an ideal $I = (f_1,...,f_r)$ and some $g \in \I$, find $s_1,\dots,s_r$ such that $g = s_1 f_1 + \dots + s_r f_r$.  
\end{block}

\vspace{1em}

\begin{itemize}
 \item The problem is easy given a Gröbner basis $g_1,\dots,g_r$ (in our case $x^n + 1$), since every element $h \in \ideal{g_1,\dots,g_r}$ can be written as $h = \sum h_i \cdot g_i$ where $\LM{h_ig_i} \leq \LM{h}$.
 \item In general, it is hard because the degree of the output may be large.
\end{itemize}

In any case, instead of solving solving GBN, we are now lifting with GBN, i.e., we keep track of our computation.

\framebreak

Example:

\begin{lstlisting}
sage: P.<x,y,z> = PolynomialRing(GF(127),order='deglex')
sage: I = Ideal(P.random_element() for _ in range(4))
sage: s = I.gens()
sage: I.groebner_basis()                                       
[x - 24, y - 20, z - 17]
sage: b = P.random_element() 
sage: b -= b.reduce(I)
sage: b in I
True
sage: a = b.lift(s)
sage: sum(a[i]*s[i] for i in range(s))
16*x*z + 50*y^2 + 53*z^2 - 57*x + 36
sage: b
16*x*z + 50*y^2 + 53*z^2 - 57*x + 36
\end{lstlisting}

Given tuples $(a,b)$ find $s$.

\end{frame}

\begin{frame}{Thank you for your attention}
\begin{center}
\begin{Huge}

\begin{center}
Questions?
\end{center}
\end{Huge}
\end{center}
\end{frame}

\end{document}
